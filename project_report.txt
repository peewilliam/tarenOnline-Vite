

-- FILE: ./package.json --
{
  "name": "tarenonline",
  "version": "1.0.0",
  "main": "index.js",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "preview": "vite preview"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "description": "",
  "dependencies": {
    "cannon-es": "^0.20.0",
    "pathfinding": "^0.4.18",
    "socket.io-client": "^4.8.1",
    "stats.js": "^0.17.0",
    "three": "^0.171.0",
    "vite": "^6.0.5"
  }
}


-- FILE: ./project_report.txt --


-- FILE: ./public/index.html --
<!DOCTYPE html>
<html>
<head>
    <title>Taren Online</title>
    <link rel='stylesheet' href='style.css'>
</head>
<body>
    <div id="loading-screen" style="display:none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: black; color: white; align-items: center; justify-content: center; z-index: 1000;">
        <div style="text-align: center;">
            <h1>Carregando...</h1>
            <div id="progress-bar-container" style="width: 300px; height: 20px; background: #444; border: 1px solid #fff; margin-top: 20px;">
                <div id="progress-bar" style="width: 0%; height: 100%; background: #0f0;"></div>
            </div>
            <p id="progress-text">0%</p>
        </div>
    </div>
    
    <script type="module" src='./main.js'></script>
</body>
</html>

-- FILE: ./public/main.js --
import Game from '@/core/Game.js';
const game = new Game();

-- FILE: ./public/style.css --
body { margin: 0; padding: 0; overflow: hidden; }

.player-name {
    color: white;
    font-size: 12px;
    text-align: center;
    background: rgba(0, 0, 0, 0.5);
    padding: 2px 4px;
    border-radius: 4px;
  }


.chat-bubble {
    display: block;
    position: relative;
    width: auto;
    max-width: 150px;
    background: transparent;
    color: white;
    padding: 5px 10px;
    border-radius: 5px;
    font-size: 14px;
    overflow: hidden;
}

.chat-message {
    background: rgba(0, 0, 0, 0.7);
    padding: 5px 10px;
    border-radius: 5px;
    margin: 5px 0;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    animation: slideUp 0.3s ease-in-out;
}

@keyframes slideUp {
    from {
        transform: translateY(10px);
        opacity: 0;
    }
    to {
        transform: translateY(0);
        opacity: 1;
    }
}



-- FILE: ./README.md --
# Documentação do Projeto Taren Online

## **Visão Geral**
Taren Online é um MMORPG top-down desenvolvido com foco em experiência multijogador, utilizando tecnologias modernas como **Three.js** para renderização 3D, **Socket.IO** para comunicação em tempo real, e **Vite** para gerenciamento do projeto. Este documento explica a estrutura do projeto, funcionalidades implementadas e como contribuir para seu desenvolvimento.

---

## **Estrutura do Projeto**

### **Árvore de Arquivos**
```
TarenOnline/
├── public/
│   ├── index.html
│   ├── main.js
│   ├── style.css
├── src/
│   ├── core/
│   │   ├── Camera.js
│   │   ├── Game.js
│   ├── entities/
│   │   ├── Player.js
│   │   ├── Enemy.js
│   ├── network/
│   │   ├── SocketManager.js
│   ├── ui/
│   │   ├── Hud.js
├── vite.config.js
├── package.json
```

### **Descrição das Pastas**

- **`public/`**: Contém arquivos estáticos servidos ao navegador, como o ponto de entrada `index.html`, o script principal `main.js`, e o estilo `style.css`.
- **`src/core/`**: Lógica central do jogo, incluindo o sistema de câmera (`Camera.js`) e a mecânica principal (`Game.js`).
- **`src/entities/`**: Define os elementos dinâmicos do jogo, como o jogador (`Player.js`) e os inimigos (`Enemy.js`).
- **`src/network/`**: Gerencia a comunicação em tempo real utilizando Socket.IO.
- **`src/ui/`**: Gerencia elementos de interface do usuário, como o HUD (`Hud.js`).

---

## **Configuração do Projeto**

### **Dependências**
As dependências do projeto são gerenciadas pelo `npm` e especificadas no arquivo `package.json`.

```json
"dependencies": {
    "socket.io-client": "^4.8.1",
    "three": "^0.171.0",
    "vite": "^6.0.5"
}
```

### **Scripts Disponíveis**
- **`npm run dev`**: Inicia o servidor de desenvolvimento.
- **`npm run build`**: Compila o projeto para produção.
- **`npm run preview`**: Previsualiza a versão compilada.

### **Configuração do Vite**
O arquivo `vite.config.js` define:
- A pasta raiz como `public/`.
- Alias para referência simplificada ao código em `src/`.
- Configurações de build para saída em `dist/`.

---

## **Componentes Principais**

### **1. Game.js**
Responsável pela inicialização do jogo, renderização e ciclo de animação.

#### Principais Funcionalidades:
- **Cena (`scene`)**: Gerencia todos os objetos renderizados.
- **Renderizador (`renderer`)**: Renderiza a cena no navegador.
- **Jogador (`player`)**: Instância do Player gerenciada pela cena.
- **Câmera (`camera`)**: Instância do Camera.js que segue o jogador.
- **HUD (`hud`)**: Exibe informações como vida e pontuação.
- **Ciclo de animação**: Atualiza todos os elementos do jogo no método `animate()`.

#### Exemplo de Uso:
```javascript
const game = new Game();
game.animate();
```

---

### **2. Camera.js**
Controla a perspectiva e o comportamento da câmera.

#### Principais Funcionalidades:
- **Seguir o Jogador**: Atualiza a posição para acompanhar o jogador.
- **Zoom**: Ajusta o campo de visão com o scroll do mouse.
- **Rotacionar com o Mouse**: Permite que o usuário gire a câmera ao clicar e arrastar.

#### Exemplo de Uso:
```javascript
const camera = new Camera(player);
camera.update();
```

---

### **3. Player.js**
Define o jogador e sua movimentação.

#### Principais Funcionalidades:
- **Movimentação com Clique**: O jogador se move até o ponto clicado no cenário.
- **Habilidades (`QWERT`)**: Ativa habilidades ao pressionar teclas designadas.
- **Indicador de Destino**: Mostra um marcador azul no ponto clicado.

#### Exemplo de Uso:
```javascript
const player = new Player();
player.update();
```

---

### **4. Enemy.js**
Define os inimigos e sua inteligência artificial.

#### Principais Funcionalidades:
- **Seguir o Jogador**: Movem-se em direção ao jogador.
- **Ataque**: Causam dano ao jogador ao se aproximar.

#### Exemplo de Uso:
```javascript
const enemy = new Enemy(player);
enemy.update();
```

---

### **5. Hud.js**
Responsável por exibir informações como vida e pontuação do jogador.

#### Principais Funcionalidades:
- **Exibição de Informações**: Mostra a vida e a pontuação em tempo real.
- **Atualização Dinâmica**: Altera os valores exibidos conforme eventos no jogo.

#### Exemplo de Uso:
```javascript
const hud = new Hud();
hud.update(player.life, game.score);
```

---

### **6. SocketManager.js**
Gerencia a comunicação em tempo real com o servidor.

#### Principais Funcionalidades:
- **Conexão ao Servidor**: Conecta-se ao servidor via Socket.IO.
- **Atualização de Jogadores**: Sincroniza a posição dos jogadores.
- **Eventos Personalizados**: Envia e recebe eventos, como movimentações e desconexões.

#### Exemplo de Uso:
```javascript
SocketManager.sendMove(player.position);
```

---

## **Fluxo de Execução do Jogo**
1. **Inicialização:** O jogo é iniciado no arquivo `main.js`.
   ```javascript
   import Game from '@/core/Game.js';
   const game = new Game();
   ```
2. **Renderização:** O `Game.js` gerencia a cena, câmera, jogador, e inimigos.
3. **Interação do Jogador:**
   - Movimento: Clique no cenário para definir o destino.
   - Habilidades: Pressione teclas `Q`, `W`, `E`, `R`, `T` para ativar.
4. **Ciclo de Atualização:** O método `animate` atualiza a cena continuamente.

---

## **Próximos Passos**
1. **Implementar Sistema de Partículas:** Adicionar efeitos visuais para habilidades e ataques.
2. **Adicionar Pathfinding:** Impedir que o jogador e inimigos atravessem obstáculos.
3. **Melhorar Interface:** Expandir o HUD para exibir mais informações.
4. **Sistema Multijogador Completo:** Sincronizar inimigos e eventos entre vários jogadores.

---

Essa documentação reflete o estado atual do projeto Taren Online e serve como guia para desenvolvedores e colaboradores.



-- FILE: ./src/core/Camera.js --
import * as THREE from 'three';

class Camera {
    constructor(player) {
        this.player = player; // Referência ao jogador para seguir
        this.camera = new THREE.PerspectiveCamera(
            75, // Campo de visão
            window.innerWidth / window.innerHeight, // Aspect ratio
            0.1, // Distância mínima de renderização
            1000 // Distância máxima de renderização
        );

        // Posição inicial
        this.camera.position.set(0, 10, 10);
        this.camera.lookAt(this.player.position);

        // Adiciona controles de zoom e rotação
        this.initZoom();
        this.initRotation();
    }

    // Atualiza a posição da câmera para seguir o jogador
    followPlayer() {
        this.camera.position.x = this.player.position.x;
        this.camera.position.z = this.player.position.z + 3; // Distância atrás do jogador
        this.camera.position.y = 10; // Altura fixa
        this.camera.lookAt(this.player.position);
    }

    // Controle de zoom usando o scroll do mouse
    initZoom() {
        window.addEventListener('wheel', (event) => {
            const delta = Math.sign(event.deltaY); // Direção do scroll
            this.camera.fov += delta * 2; // Ajusta o zoom
            // this.camera.fov = Math.max(20, Math.min(75, this.camera.fov)); // Limites
            this.camera.updateProjectionMatrix(); // Atualiza a matriz da câmera
        });
    }

    // Controle de rotação com o mouse
    initRotation() {
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };

        window.addEventListener('mousedown', () => (isDragging = true));
        window.addEventListener('mouseup', () => (isDragging = false));
        window.addEventListener('mousemove', (event) => {
            if (isDragging) {
                const deltaMove = {
                    x: event.offsetX - previousMousePosition.x,
                    y: event.offsetY - previousMousePosition.y
                };

                const rotationSpeed = 0.005; // Ajuste conforme necessário
                this.camera.position.x -= deltaMove.x * rotationSpeed;
                this.camera.position.z -= deltaMove.y * rotationSpeed;
                this.camera.lookAt(this.player.position);
            }
            previousMousePosition = {
                x: event.offsetX,
                y: event.offsetY
            };
        });
    }

    // Atualiza a câmera no loop de animação
    update() {
        this.followPlayer();
    }
}

export default Camera;


-- FILE: ./src/core/Game.js --
import * as THREE from 'three';
import Renderer from './Renderer.js';
import SocketManager from '../network/SocketManager.js';
import Player from '../entities/Player.js';
import Enemy from '../entities/Enemy.js';
import Hud from '../ui/Hud.js'; // Importação correta pela estrutura de pastas
import Camera from './Camera.js';
import Minimap from '../ui/Minimap.js';
import Map from './Map.js';
import AdvancedDebug from '../ui/AdvancedDebug.js';
import WeatherStation from './WeatherStation.js';
import { CSS2DRenderer, CSS2DObject } from 'three/examples/jsm/renderers/CSS2DRenderer.js';


class Game {
    constructor() {
        this.scene = new THREE.Scene();
        this.lastFrameTime = performance.now();
        window.game = this;
        // Criação do CSS2DRenderer
        this.labelRenderer = new CSS2DRenderer();
        this.labelRenderer.setSize(window.innerWidth, window.innerHeight);
        this.labelRenderer.domElement.style.position = 'absolute';
        this.labelRenderer.domElement.style.top = '0';
        document.body.appendChild(this.labelRenderer.domElement);
       
    

        this.init();
    }

    async init() {
        this.score = 0
        this.enemies = []
        this.socket = SocketManager;

        this.map = new Map(this.scene);
        this.limits = this.map.getLimits();
        this.physicsWorld = this.map.getPhysicsWorld();

        // Instancia o jogador e aguarda o carregamento do modelo
        this.player = new Player(this.map.getLimits(), this.physicsWorld);
        
        await this.player.loadModel(); // Aguarda o carregamento do modelo
     
        this.camera = new Camera(this.player, this.limits);
        this.rendererInstance = new Renderer(this.scene, this.camera.camera);
        this.renderer = this.rendererInstance.getRenderer();
        this.weatherStation = new WeatherStation(this.scene, this.renderer, this.player, 1800);
        this.debug = new AdvancedDebug(this.renderer, this.scene);
        this.minimap = new Minimap(this.scene, this.player, this.renderer);
        this.hud = new Hud();

        

        this.camera.camera.position.z = 5;

        // Lista de objetos clicáveis
        this.clickables = [this.map.ground, this.player.model];

  
        // Cria Celecinaveis
        this.createCollectibles();
         
        this.enemies = [];
        for (let i = 0; i < 5; i++) { // Adiciona 5 inimigos iniciais
            const enemy = new Enemy(this.player, this.map);
            this.enemies.push(enemy);
            this.scene.add(enemy.model);
        }

        // adicionar inimigos
        // this.enemies.forEach(enemy => this.scene.add(enemy.model));


        this.goal = new THREE.Mesh(
            new THREE.BoxGeometry(1, 1, 1),
            new THREE.MeshStandardMaterial({ color: 0x00ff00 })
        );
        this.goal.position.set(5, 0, -5);
        this.scene.add(this.goal);

        // Obtém os limites do chão dinamicamente
        const halfWidth = window.game.map.ground.geometry.parameters.width;
        const halfHeight = window.game.map.ground.geometry.parameters.height;
        const gridHelper = new THREE.GridHelper(halfWidth, halfHeight, 0x00ff00, 0x000000); // Grade de 20x20
        // this.scene.add(gridHelper);

        window.addEventListener('resize', this.onResize.bind(this));

        this.animate();
    }

    checkGoal() {
        const distance = this.goal.position.distanceTo(this.player.position);
        if (distance < 1) {
            console.log("You win!");
            this.nextLevel();
            // Reinicie o jogo ou exiba uma mensagem de vitória
        }
    }



    createCollectibles() {
        this.collectibles = [];
        for (let i = 0; i < 5; i++) {
            const collectible = new THREE.Mesh(
                new THREE.SphereGeometry(0.5),
                new THREE.MeshStandardMaterial({ color: 0xffff00 })
            );
            collectible.position.set(
                Math.random() * 10 - 5,
                0,
                Math.random() * 10 - 5
            );
            this.collectibles.push(collectible);
            this.scene.add(collectible);
        }
    }

    checkCollectibles() {
        for (let i = this.collectibles.length - 1; i >= 0; i--) {
            const collectible = this.collectibles[i];
            const distance = collectible.position.distanceTo(this.player.position);
            if (distance < 1) {
                console.log("Item coletado!");
                this.score += 5; // Incrementa a pontuação
                this.scene.remove(collectible);
                this.collectibles.splice(i, 1);
            }
        }
    }

    nextLevel() {
        console.log("Next level!");

        this.player.level += 1;

        // Aumenta o número de inimigos
        const newEnemy = new Enemy(this.player);
        this.enemies.push(newEnemy);
        this.scene.add(newEnemy.model);



        this.goal.position.set(
            Math.random() * 10 - 5,
            0,
            Math.random() * 10 - 5
        );


    }

    onResize() {
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        this.camera.camera.aspect = window.innerWidth / window.innerHeight;
        this.labelRenderer.setSize(window.innerWidth, window.innerHeight); // Atualiza o tamanho do CSS2DRenderer
        this.camera.camera.updateProjectionMatrix();
    }

    animate() {
        requestAnimationFrame(this.animate.bind(this));

        const now = performance.now();
        const deltaTime = (now - (this.lastFrameTime || now)) / 1000;

        // if (deltaTime < 1 / 60) return; 

        this.lastFrameTime = now;

        // Atualize o clima
        this.weatherStation.update(1 / 60);

        this.debug.update(); // Atualiza o depurador a cada frame
        // this.debugInfo.begin(); // Inicia a medição de desempenho

        // Atualiza física do Cannon.js
        this.map.getPhysicsWorld().step(1 / 60);

        // Atualiza a posição dos objetos com base no mundo físico
        this.map.obstacles.forEach((obstacle) => {
            const body = obstacle.body; // Supondo que cada obstáculo tenha um corpo físico associado
            if (body) {
                obstacle.position.copy(body.position); // Sincroniza posição
            }
        });

        this.player.update(deltaTime);
        this.camera.update(); // Atualiza a câmera no loop de animação

        this.map.checkCollisions(this.player); // Chama a verificação de colisões no mapa

        this.checkGoal();
        this.checkCollectibles();

        // Envie a posição do jogador
        this.socket.sendMove(this.player.position);

        // Atualiza os inimigos
        this.enemies.forEach(enemy => enemy.update(deltaTime));


        // atualiza a hud
        this.hud.update(this.player.life, this.score); // Atualiza a HUD

        // Atualize o minimapa sem interferir nos obstáculos
        this.minimap.update();



        this.renderer.render(this.scene, this.camera.camera); // Use this.camera.camera

        // Renderiza a cena e as labels

        this.labelRenderer.render(this.scene, this.camera.camera); // Renderiza as labels

        // this.debugInfo.end(); // Finaliza a medição de desempenho
    }
}

export default Game;


-- FILE: ./src/core/Map.js --
import * as THREE from 'three';
import { EXRLoader } from 'three/examples/jsm/loaders/EXRLoader';
import { World, Body, Box, Sphere, Vec3 } from 'cannon-es';

class Map {
    constructor(scene) {
        this.scene = scene;
        this.obstacles = [];
        this.physicsWorld = new World(); // Mundo de física Cannon.js
        this.physicsWorld.gravity.set(0, -9.82, 0); // Configura gravidade

        // Ajuste o tamanho do plano
        const planeSize = 100;

        const textureLoader = new THREE.TextureLoader();

        // Carregando as texturas
        const diffuseTexture = textureLoader.load(
            '/assets/world/textures/creaked/cracked_concrete_diff_1k.jpg',
            (texture) => console.log('Diffuse texture loaded:', texture),
            undefined,
            (error) => console.error('Error loading diffuse texture:', error)
        );

        const armTexture = textureLoader.load(
            '/assets/world/textures/creaked/cracked_concrete_arm_1k.jpg',
            (texture) => console.log('ARM texture loaded:', texture),
            undefined,
            (error) => console.error('Error loading ARM texture:', error)
        );

        const normalTexture = textureLoader.load(
            '/assets/world/textures/creaked/cracked_concrete_nor_gl_1k.jpg',
            (texture) => console.log('Normal texture loaded:', texture),
            undefined,
            (error) => console.error('Error loading normal texture:', error)
        );

        // Ajustando repetição das texturas
        [diffuseTexture, armTexture, normalTexture].forEach((texture) => {
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            texture.repeat.set(15, 15); // Ajuste o valor para controlar a densidade
        });


        // Define o chão com texturas PBR
        this.ground = new THREE.Mesh(
            new THREE.PlaneGeometry(planeSize, planeSize, 1, 1),
            new THREE.MeshStandardMaterial({
                map: diffuseTexture,         // Textura base
                roughnessMap: armTexture,    // Mapa de rugosidade
                metalnessMap: armTexture,    // Mapa de metalicidade
                normalMap: normalTexture,    // Mapa de normais
                roughness: 0.9, // Ajuste adicional de rugosidade
                metalness: 0.0, // Sem metalicidade
            })
        );
        this.ground.rotation.x = -Math.PI / 2; // Deitar o plano
        this.ground.receiveShadow = true;
        this.scene.add(this.ground);

        // Corpo físico para o chão
        const groundBody = new Body({
            mass: 0, // Estático
            shape: new Box(new Vec3(planeSize / 2, 0.1, planeSize / 2)), // Tamanho do chão
        });
        groundBody.position.set(0, 0, 0);
        this.physicsWorld.addBody(groundBody);

        // Calcula os limites com base no tamanho do chão
        this.limits = {
            minX: -planeSize / 2,
            maxX: planeSize / 2,
            minZ: -planeSize / 2,
            maxZ: planeSize / 2,
        };

        // Cria os elementos da vila
        this.createPaths();
        this.createHouses();
        this.createTrees();
        this.createFences();
    }

    loadTexture(loader, path, type) {
        if (path.endsWith('.exr')) {
            const exrLoader = new EXRLoader();
            try {
                return exrLoader.load(
                    path,
                    (texture) => {
                        console.log(`${type} texture loaded successfully:`, path);
                    },
                    undefined,
                    (error) => {
                        console.error(`Error loading ${type} texture:`, path, error);
                    }
                );
            } catch (error) {
                console.error(`Critical error loading ${type} texture:`, path, error);
            }
        } else {
            return loader.load(
                path,
                (texture) => {
                    console.log(`${type} texture loaded successfully:`, path);
                },
                undefined,
                (error) => {
                    console.error(`Error loading ${type} texture:`, path, error);
                }
            );
        }
    }


    createPaths() {
        // Cria caminhos de pedra pela vila
        const pathMaterial = new THREE.MeshStandardMaterial({ color: 0x808080 });

        const paths = [
            { size: [2, 40, 0.1], position: [0, 0.01, 0] }, // Caminho principal
            { size: [2, 10, 0.1], position: [-10, 0.01, 15] }, // Caminho lateral esquerdo
            { size: [2, 10, 0.1], position: [10, 0.01, -15] }, // Caminho lateral direito
        ];

        paths.forEach(({ size, position }) => {
            const path = new THREE.Mesh(new THREE.BoxGeometry(size[0], size[2], size[1]), pathMaterial);
            path.rotation.x = -Math.PI / 2;
            path.position.set(position[0], position[1], position[2]);
            this.scene.add(path);
        });
    }

    createHouses() {
        const houseMaterial = new THREE.MeshStandardMaterial({ color: 0xaaaaaa });

        const houses = [
            { size: [6, 4, 6], position: [-12, 2, 12] }, // Casa 1
            { size: [6, 4, 6], position: [12, 2, -12] }, // Casa 2
        ];

        houses.forEach(({ size, position }) => {
            const house = new THREE.Mesh(new THREE.BoxGeometry(...size), houseMaterial);
            house.castShadow = true;
            house.position.set(...position);
            this.scene.add(house);

            // Adiciona corpo físico para a casa
            const houseBody = new Body({
                mass: 0, // Estático
                position: new Vec3(...position),
                shape: new Box(new Vec3(size[0] / 2, size[1] / 2, size[2] / 2)), // Tamanho da casa
            });
            this.physicsWorld.addBody(houseBody);
            this.obstacles.push(houseBody); // Adiciona à lista de obstáculos

            const roof = new THREE.Mesh(
                new THREE.ConeGeometry(4, 3, 4),
                new THREE.MeshStandardMaterial({ color: 0x8b0000 })
            );
            roof.position.set(position[0], position[1] + 3, position[2]);
            roof.castShadow = true;
            this.scene.add(roof);
        });
    }

    createTrees() {
        const trunkMaterial = new THREE.MeshStandardMaterial({ color: 0x8b4513 });
        const foliageMaterial = new THREE.MeshStandardMaterial({ color: 0x228b22 });

        for (let i = 0; i < 10; i++) {
            const trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.5, 0.5, 6), trunkMaterial);
            trunk.position.set(Math.random() * 40 - 20, 1, Math.random() * 40 - 20);
            trunk.castShadow = true;
            this.scene.add(trunk);

             // Adiciona corpo físico para o tronco
              // Adiciona corpo físico para o tronco
            const trunkBody = new Body({
                mass: 0, // Estático
                position: new Vec3(trunk.position.x, trunk.position.y + 3, trunk.position.z),
                shape: new Box(new Vec3(0.5, 3, 0.5)), // Tamanho do tronco
            });
            this.physicsWorld.addBody(trunkBody);
            this.obstacles.push(trunkBody); // Adiciona à lista de obstáculos

            const foliage = new THREE.Mesh(new THREE.SphereGeometry(1.5, 16, 16), foliageMaterial);
            foliage.position.set(trunk.position.x, trunk.position.y + 3, trunk.position.z);
            foliage.castShadow = true;
            this.scene.add(foliage);
        }
    }

    createFences() {
        const fenceMaterial = new THREE.MeshStandardMaterial({ color: 0xdeb887 });

        for (let i = -20; i <= 20; i += 2) {
            const fencePost = new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0.2, 1), fenceMaterial);
            fencePost.position.set(i, 0.5, -20);
            this.scene.add(fencePost);

            // Adiciona corpo físico para o poste da cerca
            const fencePostBody = new Body({
                mass: 0, // Estático
                position: new Vec3(i, 0.5, -20),
                shape: new Box(new Vec3(0.2, 0.5, 0.2)), // Tamanho do poste
            });
            this.physicsWorld.addBody(fencePostBody);
            this.obstacles.push(fencePostBody); // Adiciona à lista de obstáculos

            const fencePostZ = new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0.2, 1), fenceMaterial);
            fencePostZ.position.set(-20, 0.5, i);
            this.scene.add(fencePostZ);

            // Adiciona corpo físico para o poste da cerca na direção Z
            const fencePostZBody = new Body({
                mass: 0, // Estático
                position: new Vec3(-20, 0.5, i),
                shape: new Box(new Vec3(0.2, 0.5, 0.2)), // Tamanho do poste
            });
            this.physicsWorld.addBody(fencePostZBody);
            this.obstacles.push(fencePostZBody); // Adiciona à lista de obstáculos
        }
    }

    checkCollisions(player) {
        for (const obstacle of this.obstacles) {
            const distance = obstacle.position.distanceTo(player.position);

            if (distance < 1) {
                // console.log("Collision detected!");
            }
        }
    }

    getLimits() {
        return this.limits;
    }

    getPhysicsWorld() {
        return this.physicsWorld;
    }
}

export default Map;


-- FILE: ./src/core/Pathfinding.js --
import PF from 'pathfinding';

class Pathfinding {
    constructor(gridSize = { width: 100, height: 100 }) {
        this.grid = new PF.Grid(gridSize.width, gridSize.height); // Cria a grade com as dimensões especificadas
        this.finder = new PF.AStarFinder();
    }

    findPath(start, end) {
        // Verifica e ajusta os limites das coordenadas
        const isWithinBounds = (point) =>
            point.x >= 0 && point.x < this.grid.width &&
            point.z >= 0 && point.z < this.grid.height;
    
        if (!isWithinBounds(start) || !isWithinBounds(end)) {
            console.error(`Coordenadas fora dos limites: start(${start.x}, ${start.z}), end(${end.x}, ${end.z})`);
            return [];
        }
    
        // Calcula o caminho
        const path = this.finder.findPath(start.x, start.z, end.x, end.z, this.grid.clone());
    
        if (path.length === 0) {
            console.warn(`Nenhum caminho encontrado entre start(${start.x}, ${start.z}) e end(${end.x}, ${end.z})`);
        }
    
        return path; // Mantém as coordenadas no formato da grade
    }
    

    setObstacle(x, z) {
        const gridX = x + 10; // Ajuste para alinhar com a grade
        const gridZ = z + 10;
    
        // Verifica se as coordenadas estão dentro dos limites
        if (gridX >= 0 && gridX < this.grid.width && gridZ >= 0 && gridZ < this.grid.height) {
            this.grid.setWalkableAt(gridX, gridZ, false);
        } else {
            console.error(`Coordenadas fora do limite da grade: (${gridX}, ${gridZ})`);
        }
    }

    resetGrid(gridSize) {
        this.grid = new PF.Grid(gridSize.width, gridSize.height);
    }
}

export default Pathfinding;


-- FILE: ./src/core/Renderer.js --
import * as THREE from 'three';

class Renderer {
    constructor(scene, camera) {
        this.renderer = new THREE.WebGLRenderer({
            antialias: true,
            powerPreference: "high-performance", // Prioriza o uso da GPU
            alpha: false, // Desativa transparência para melhor desempenho
            precision: "highp", // Alta precisão para shaders
            logarithmicDepthBuffer: true, // Melhor precisão de profundidade em grandes escalas
        });

        

        // Configura o tamanho do renderizador para a janela
        this.renderer.setSize(window.innerWidth, window.innerHeight);

        // Ativa o mapeamento de sombras
        this.renderer.shadowMap.enabled = true;
        this.renderer.shadowMap.type = THREE.PCFSoftShadowMap; // Sombra de alta qualidade

        // Adiciona o canvas à página
        document.body.appendChild(this.renderer.domElement);

        // Configura o evento de redimensionamento
        window.addEventListener('resize', () => {
            this.onWindowResize(camera);
        });
    }

    onWindowResize(camera) {
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
    }

    render(scene, camera) {
        this.renderer.render(scene, camera);
    }

    getRenderer() {
        return this.renderer;
    }
}

export default Renderer;


-- FILE: ./src/core/WeatherStation.js --
import * as THREE from 'three';

class WeatherStation {
    constructor(scene, renderer, player, totalCycleDuration) {
        this.scene = scene;
        this.renderer = renderer;
        this.player = player;

        // Configurações de ciclo dia/noite
        this.totalCycleDuration = totalCycleDuration;

        // Inicializa o relógio do jogo
        this.currentTime = 0;
        this.currentHour = 6; // Hora inicial no ciclo
        this.clockElement = this.createClockHUD();

        // Configuração inicial do Sol
        this.sunLight = new THREE.DirectionalLight(0xffffff, 1);
        this.sunLight.castShadow = true;
        this.sunLight.shadow.mapSize.width = 2048;
        this.sunLight.shadow.mapSize.height = 2048;
        this.sunLight.shadow.camera.left = -100;
        this.sunLight.shadow.camera.right = 100;
        this.sunLight.shadow.camera.top = 100;
        this.sunLight.shadow.camera.bottom = -100;
        this.sunLight.shadow.camera.near = 1;
        this.sunLight.shadow.camera.far = 300;
        this.scene.add(this.sunLight);

        // Luz de lua para a noite
        this.moonLight = new THREE.DirectionalLight(0x113355, 0.3); // Azul escuro fraco
        this.scene.add(this.moonLight);

        // Luz ambiente dinâmica
        this.ambientLight = new THREE.AmbientLight(0xffffff, 0.2); // Luz ambiente inicial
        this.scene.add(this.ambientLight);

        // Luz de foco no jogador
        this.spotLight = new THREE.SpotLight(0xffffff, 2, 30, Math.PI / 6, 0.5);
        this.spotLight.castShadow = true;
        this.scene.add(this.spotLight);
        this.scene.add(this.spotLight.target);

        // Plano de fundo dinâmico
        this.backgroundColorDay = new THREE.Color(0x87ceeb); // Céu azul claro
        this.backgroundColorNight = new THREE.Color(0x0b1d36); // Céu noturno azul escuro
        this.renderer.setClearColor(this.backgroundColorDay);

        // Variáveis de controle do sol
        this.sunSpeed = (Math.PI * 2) / this.totalCycleDuration;
        this.sunRadius = 100; // Raio da órbita do sol
        this.sunHeight = 50; // Altura máxima do sol

        // Configuração inicial da luminosidade por hora
        this.hourlyLuminosity = Array(24).fill(0);
        this.setDayNightRatio(70, 30); // Define 50% dia e 50% noite por padrão

        // Criar botões de controle para testes
        this.createWeatherControls();
        this.createClouds()
    }

    createRain() {
        const rainGeometry = new THREE.BufferGeometry();
        const rainCount = 1000;
        const positions = [];
        const velocities = [];
    
        for (let i = 0; i < rainCount; i++) {
            positions.push(
                Math.random() * 200 - 100, // X: dentro de um quadrado 200x200
                Math.random() * 100 + 50, // Y: altura inicial (acima do jogador)
                Math.random() * 200 - 100 // Z
            );
            velocities.push(Math.random() * 0.5 + 0.2); // Velocidade de cada partícula
        }
    
        rainGeometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
        rainGeometry.setAttribute('velocity', new THREE.Float32BufferAttribute(velocities, 1));
    
        const rainMaterial = new THREE.PointsMaterial({
            color: 0xaaaaaa,
            size: 0.2,
            transparent: true,
            opacity: 0.6,
        });
    
        this.rainParticles = new THREE.Points(rainGeometry, rainMaterial);
        this.scene.add(this.rainParticles);
    }
    
    updateRain() {
        if (!this.rainParticles) return;
    
        const positions = this.rainParticles.geometry.attributes.position.array;
        const velocities = this.rainParticles.geometry.attributes.velocity.array;
    
        for (let i = 0; i < positions.length; i += 3) {
            positions[i + 1] -= velocities[i / 3]; // Move Y para baixo
    
            // Reinicia a posição da partícula se ela sair do campo de visão
            if (positions[i + 1] < 0) {
                positions[i + 1] = Math.random() * 100 + 50;
                positions[i] = Math.random() * 200 - 100;
                positions[i + 2] = Math.random() * 200 - 100;
            }
        }
    
        this.rainParticles.geometry.attributes.position.needsUpdate = true;
    }

    enableRain() {
        if (!this.rainParticles) {
            this.createRain();
        }
        // this.setRainyGround();
    }
    
    disableRain() {
        if (this.rainParticles) {
            this.scene.remove(this.rainParticles);
            this.rainParticles.geometry.dispose();
            this.rainParticles.material.dispose();
            this.rainParticles = null;
        }
        this.restoreGround();
    }
    

    setDayNightRatio(dayPercentage, nightPercentage) {
        const totalHours = 24;
        const dayHours = Math.round((dayPercentage / 100) * totalHours);
        const nightHours = totalHours - dayHours;

        this.hourlyLuminosity = Array(24).fill(0);

        // Preenche as horas do dia com luminosidade crescente e decrescente
        for (let i = 0; i < dayHours / 2; i++) {
            this.hourlyLuminosity[i] = i / (dayHours / 2);
            this.hourlyLuminosity[23 - i] = i / (dayHours / 2);
        }

        // Preenche as horas centrais do dia com luminosidade máxima
        for (let i = Math.floor(dayHours / 2); i < totalHours - Math.floor(nightHours / 2); i++) {
            this.hourlyLuminosity[i] = 1;
        }

        // Atualiza a luminosidade para as horas noturnas
        for (let i = 0; i < nightHours / 2; i++) {
            const index = (dayHours / 2 + i) % 24;
            this.hourlyLuminosity[index] = 1 - (i / (nightHours / 2));
            this.hourlyLuminosity[(index + nightHours) % 24] = 1 - (i / (nightHours / 2));
        }

        // Atualiza a exibição das porcentagens
        this.updateDayNightDisplay(dayPercentage, nightPercentage);
    }

    update(deltaTime) {
        // Atualiza o tempo do ciclo
        this.currentTime += deltaTime;

        if (this.currentTime > this.totalCycleDuration) {
            this.currentTime = 0; // Reinicia o ciclo
        }

        // Calcula o horário atual do jogo
        const gameTime = this.currentTime / this.totalCycleDuration * 24;
        this.currentHour = Math.floor(gameTime);
        this.updateClockHUD();

        this.updateClouds()

        // Define a intensidade da luz com base na hora atual
        const luminosity = this.hourlyLuminosity[this.currentHour];
        this.updateLighting(luminosity);

        // Calcula a posição do sol com base no tempo
        const angle = (this.currentTime / this.totalCycleDuration) * Math.PI * 2;
        const sunY = Math.sin(angle) * this.sunHeight;
        const sunX = Math.cos(angle) * this.sunRadius;
        const sunZ = Math.sin(angle) * this.sunRadius;

        this.sunLight.position.set(sunX, sunY, sunZ);
        this.sunLight.target.position.set(0, 0, 0);
        this.sunLight.target.updateMatrixWorld();

        // Ajusta a iluminação e o fundo com base na luminosidade
        this.sunLight.intensity = luminosity;
        this.ambientLight.intensity = luminosity * 0.5;
        this.moonLight.intensity = 1 - luminosity; // Complementar ao sol

        this.renderer.setClearColor(
            this.backgroundColorDay.clone().lerp(this.backgroundColorNight, 1 - luminosity)
        );

         // Atualiza a chuva
        this.updateRain();
    }

    setRainyGround() {
        if (!this.originalGroundMaterial) {
            this.originalGroundMaterial = this.scene.getObjectByName('ground').material.clone();
        }
    
        const wetMaterial = this.originalGroundMaterial.clone();
        wetMaterial.envMapIntensity = 1.5; // Aumenta reflexos
        wetMaterial.roughness = 0.3; // Chão mais liso
        wetMaterial.metalness = 0.6;
    
        this.scene.getObjectByName('ground').material = wetMaterial;
    }
    
    restoreGround() {
        if (this.originalGroundMaterial) {
            this.scene.getObjectByName('ground').material = this.originalGroundMaterial;
        }
    }

    createClouds() {
        const textureLoader = new THREE.TextureLoader();
        const cloudTexture = textureLoader.load(
            '/assets/world/textures/cloud/cloud.png',
            (texture) => console.log('cloud texture loaded:', texture),
            undefined,
            (error) => console.error('Error loading cloud texture:', error)
        );
        const cloudMaterial = new THREE.SpriteMaterial({ map: cloudTexture, transparent: true, opacity: 0.8 });
        this.clouds = [];
    
        for (let i = 0; i < 10; i++) {
            const cloud = new THREE.Sprite(cloudMaterial);
            cloud.position.set(
                Math.random() * 400 - 200,
                Math.random() * 100 + 50,
                Math.random() * 400 - 200
            );
            cloud.scale.set(50, 50, 1);
            this.scene.add(cloud);
            this.clouds.push(cloud);
        }

    
    }
    
    updateClouds(deltaTime) {
        if (!this.clouds) return;
    
        this.clouds.forEach(cloud => {
            cloud.position.x += deltaTime * 5;
            if (cloud.position.x > 200) {
                cloud.position.x = -200;
            }
        });
    }

    updateLighting(luminosity) {
        const targetSunIntensity = luminosity;
        const targetMoonIntensity = 1 - luminosity;
    
        // Interpolação suave
        this.sunLight.intensity += (targetSunIntensity - this.sunLight.intensity) * 0.1;
        this.moonLight.intensity += (targetMoonIntensity - this.moonLight.intensity) * 0.1;
        this.ambientLight.intensity += (luminosity * 0.5 - this.ambientLight.intensity) * 0.1;
    }
    

    createClockHUD() {
        const clockContainer = document.createElement('div');
        clockContainer.style.position = 'absolute';
        clockContainer.style.top = '10px';
        clockContainer.style.left = '50%';
        clockContainer.style.transform = 'translateX(-50%)';
        clockContainer.style.color = 'white';
        clockContainer.style.fontFamily = 'Arial, sans-serif';
        clockContainer.style.fontSize = '15px';
        clockContainer.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';
        clockContainer.style.padding = '5px 10px';
        clockContainer.style.borderRadius = '5px';
        document.body.appendChild(clockContainer);

        clockContainer.innerHTML = `
            <div id="game-clock">06:00 AM</div>
            <div id="weather-controls" style="margin-top: 10px;">
            <button id="enable-rain">Chuva</button>
                <button id="disable-rain">Sem Chuva</button>
                <input type="range" id="time-slider" min="0" max="24" value="0" step="0.1" style="width: 50%; margin-top: 10px;">
                
            </div>
            <div id="day-night-info" style="margin-top: 10px;">
                <span id="day-percentage">Dia: 50%</span>
                <span id="night-percentage" style="margin-left: 10px;">Noite: 50%</span>
            </div>
        `;

        const slider = clockContainer.querySelector('#time-slider');
        slider.addEventListener('input', (event) => {
            const selectedTime = parseFloat(event.target.value);
            this.currentTime = (selectedTime / 24) * this.totalCycleDuration;
        });

        this.clockElement = clockContainer.querySelector('#game-clock');
        return this.clockElement;
    }

    updateDayNightDisplay(dayPercentage, nightPercentage) {
        const dayElement = document.getElementById('day-percentage');
        const nightElement = document.getElementById('night-percentage');
    
        const daySeconds = Math.round((dayPercentage / 100) * this.totalCycleDuration);
        const nightSeconds = this.totalCycleDuration - daySeconds;
    
        if (dayElement && nightElement) {
            dayElement.textContent = `Dia:  ${daySeconds/60}m`;
            nightElement.textContent = `Noite: ${nightSeconds/60}m`;
        }
    }
    

    createWeatherControls() {
        document.getElementById('enable-rain').addEventListener('click', () => {
            this.enableRain();
        });

        document.getElementById('disable-rain').addEventListener('click', () => {
            this.disableRain();
        });
    }

    updateClockHUD() {
        const hours = this.currentHour.toString().padStart(2, '0');
        const minutes = Math.floor((this.currentTime % (this.totalCycleDuration / 24)) * 60 / (this.totalCycleDuration / 24)).toString().padStart(2, '0');
        const period = this.currentHour < 12 ? 'AM' : 'PM';
        this.clockElement.innerHTML = `${hours}:${minutes} ${period}`;
    }
}

export default WeatherStation;


-- FILE: ./src/entities/Enemy.js --
import * as THREE from 'three';
import Pathfinding from '@/core/Pathfinding.js';
import PF from 'pathfinding';

class Enemy {
    constructor(player, map) {
        this.player = player; // Referência ao jogador
        this.map = map; // Referência ao mapa para acessar obstáculos
        this.pathfinding = new Pathfinding({ width: 20, height: 20 }); // Instância de pathfinding
        this.finder = new PF.AStarFinder();

        // Configurar a grade do pathfinding
        this.updateGrid();

        // Configuração do modelo do inimigo
        this.model = new THREE.Mesh(
            new THREE.BoxGeometry(1, 1, 1),
            new THREE.MeshStandardMaterial({ color: 0xff0000 })
        );
        this.position = new THREE.Vector3(
            Math.random() * 10 - 5,
            0,
            Math.random() * 10 - 5
        );
        this.model.position.copy(this.position);
        this.speed = 1.0;
        this.path = [];
        this.currentPathIndex = 0;
    }

    updateGrid() {
        // Atualiza a grade com os obstáculos do mapa
        this.map.obstacles.forEach(obstacle => {
            const { x, z } = obstacle.position;
            this.pathfinding.setObstacle(Math.floor(x), Math.floor(z));
        });
    }
    convertWorldToGrid(position) {
        const gridX = Math.floor(position.x + this.map.limits.maxX / 2); // Ajusta para a grade
        const gridZ = Math.floor(position.z + this.map.limits.maxZ / 2);
        return { x: gridX, z: gridZ };
    }
    
    convertGridToWorld(gridPosition) {
        const worldX = gridPosition.x - this.map.limits.maxX / 2;
        const worldZ = gridPosition.z - this.map.limits.maxZ / 2;
        return new THREE.Vector3(worldX, 0, worldZ);
    }

    findPathToPlayer() {
        const start = this.convertWorldToGrid(this.position);
        const end = this.convertWorldToGrid(this.player.position);
    
        if (!this.pathfinding.grid.isInside(start.x, start.z) || 
            !this.pathfinding.grid.isInside(end.x, end.z)) {
            console.error(`Coordenadas fora dos limites: start(${start.x}, ${start.z}), end(${end.x}, ${end.z})`);
            return;
        }
    
        this.path = this.pathfinding.findPath(start, end);
        this.currentPathIndex = 0;
    }

    findPath(start, end) {
        if (!this.isInside(start.x, start.z) || !this.isInside(end.x, end.z)) {
            console.error(`Coordenadas fora dos limites: start(${start.x}, ${start.z}), end(${end.x}, ${end.z})`);
            return [];
        }
        return this.finder.findPath(start.x, start.z, end.x, end.z, this.grid.clone());
    }

    isInside(x, z) {
        return x >= 0 && x < this.gridSize.width && z >= 0 && z < this.gridSize.height;
    }


    moveAlongPath(deltaTime) {
        if (this.path.length === 0 || this.currentPathIndex >= this.path.length) {
            return;
        }

        const nextPoint = this.path[this.currentPathIndex];
        const targetPosition = new THREE.Vector3(nextPoint[0], 0, nextPoint[1]);

        const direction = new THREE.Vector3().subVectors(targetPosition, this.position).normalize();
        this.position.add(direction.multiplyScalar(this.speed * deltaTime));

        if (this.position.distanceTo(targetPosition) < 0.1) {
            this.currentPathIndex++;
        }

        this.model.position.copy(this.position);
    }

    attack(player) {
        const distance = this.position.distanceTo(player.position);
        if (distance < 1) {
            player.loseLife(10); // Causa dano ao jogador
            console.log("Enemy attacked!");
        }
    }

    update(deltaTime) {
        if (this.path.length === 0 || this.currentPathIndex >= this.path.length) {
            this.findPathToPlayer();
        }
        this.moveAlongPath(deltaTime);
        this.attack(this.player);
    }
}

export default Enemy;


-- FILE: ./src/entities/Player.js --
import * as THREE from 'three';
import Pathfinding from '@/core/Pathfinding.js';
import { Body, Sphere, Vec3 } from 'cannon-es';
import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';
import { DRACOLoader } from 'three/examples/jsm/loaders/DRACOLoader.js';
import { AnimationMixer } from 'three';
import { CSS2DRenderer, CSS2DObject } from 'three/examples/jsm/renderers/CSS2DRenderer.js';

class Player {
  constructor(limits, physicsWorld) {
    this.limits = limits;
    this.physicsWorld = physicsWorld;
    this.model = null;
    this.position = new THREE.Vector3(0, 0.5, 0);
    this.speed = 2;
    this.life = 200;
    this.alive = true;
    this.targetPosition = new THREE.Vector3();
    this.moving = false;
    this.mousePressed = false;
    this.mixer = null; // Para animações
    this.animations = {}; // Para armazenar as animações
    this.currentAnimation = 'idle'; // Animação atual

    
  }

  async loadModel() {
    const loader = new GLTFLoader();
    const dracoLoader = new DRACOLoader();
    dracoLoader.setDecoderPath('https://www.gstatic.com/draco/v1/decoders/');
    loader.setDRACOLoader(dracoLoader);

    try {
      const gltf = await loader.loadAsync('/assets/player/human-man/human-man.glb');
      this.model = gltf.scene;
      this.model.scale.set(0.1, 0.1, 0.1); // Ajuste da escala
      this.model.traverse((node) => {
        if (node.isMesh) {
          node.castShadow = true;
        }
      });
      window.game.scene.add(this.model);
      this.model.position.copy(this.position);
      this.initPlayerPhysics();
      this.initMouseInput();
      this.initKeyboardInput();

      // Inicializa o AnimationMixer
      this.mixer = new AnimationMixer(this.model);
      gltf.animations.forEach((clip) => {
        this.animations[clip.name] = this.mixer.clipAction(clip); // Armazena a animação
      });

      // Inicia com a animação idle
      this.playAnimation('idle');

      // Criação do nome do jogador
      const nameDiv = document.createElement('div');
      nameDiv.className = 'player-name';
      nameDiv.textContent = 'IndexJS'; // Nome do jogador
      nameDiv.style.color = 'white'; // Cor do texto
      nameDiv.style.fontSize = '12px'; // Tamanho da fonte
      nameDiv.style.fontFamily = 'Arial, sans-serif'; // Fonte
      const nameLabel = new CSS2DObject(nameDiv);
      nameLabel.position.set(0, 25, 0); // Ajuste a posição acima da cabeça do jogador
      this.model.add(nameLabel); // Adiciona o nome ao modelo do jogador

      // Chat Bubble
      const chatDiv = document.createElement('div');
      chatDiv.className = 'chat-bubble';
      chatDiv.style.display = 'block';
      const chatBubble = new CSS2DObject(chatDiv);
      chatBubble.position.set(0, 30, 0);
      this.model.add(chatBubble);
     
    } catch (error) {
      console.error('Erro ao carregar o modelo GLB:', error);
    }
  }

  playAnimation(state) {
    if (this.currentAnimation === state) return;

    const prevAction = this.animations[this.currentAnimation];
    const nextAction = this.animations[state];

    if (prevAction) {
      prevAction.fadeOut(0.2); // Transição suave
    }

    if (nextAction) {
      nextAction.reset().fadeIn(0.2).play();
      this.currentAnimation = state; // Atualiza a animação atual
    }
  }

  initPlayerPhysics() {
    this.body = new Body({
      mass: 1, // Dinâmico
      position: new Vec3(0, 0.5, 0), // Posição inicial
      shape: new Sphere(0.5), // Forma do corpo
    });
    this.physicsWorld.addBody(this.body);
  }

  loseLife(damage = 10) {
    this.life -= damage;
    if (this.life <= 0) {
      console.log("Game Over!");
    }
  }

  initMouseInput() {
    window.addEventListener('contextmenu', (event) => event.preventDefault());

    window.addEventListener('mousedown', (event) => {
      if (event.button === 2) {
        this.mousePressed = true;
        this.updateTargetPosition(event);
      }
    });

    window.addEventListener('mousemove', (event) => {
      if (this.mousePressed) {
        this.updateTargetPosition(event);
      }
    });

    window.addEventListener('mouseup', (event) => {
      if (event.button === 2) {
        this.mousePressed = false;
      }
    });
  }

  updateTargetPosition(event) {
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();

    mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
    mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

    raycaster.setFromCamera(mouse, window .game.camera.camera);

    const intersects = raycaster.intersectObjects(window.game.clickables, true);

    if (intersects.length > 0) {
      const point = intersects[0].point;
      const ground = window.game.map.ground; 
      const halfWidth = ground.geometry.parameters.width / 2;
      const halfHeight = ground.geometry.parameters.height / 2;

      if (point.x >= -halfWidth && point.x <= halfWidth && point.z >= -halfHeight && point.z <= halfHeight) {
        this.setDestination(point);
      } else {
        console.warn('Clique fora dos limites do chão!');
      }
    }
  }

  initKeyboardInput() {
    window.addEventListener('keydown', (event) => {
      switch (event.key.toLowerCase()) {
        case 'q':
          this.useSkill('Skill 1');
          break;
        case 'w':
          this.useSkill('Skill 2');
          break;
        case 'e':
          this.useSkill('Skill 3');
          break;
        case 'r':
          this.useSkill('Skill 4');
          break;
        case 't':
          this.useSkill('Skill 5');
          break;
        default:
          break;
      }
    });
  }

  useSkill(skillName) {
    console.log(`${skillName} ativada!`);
  }

  setDestination(destination) {
    this.targetPosition.copy(destination);
    this.moving = true;
  }

  update(deltaTime) {
    if (this.moving) {
      const direction = new THREE.Vector3()
        .subVectors(this.targetPosition, this.position)
        .normalize();

      const targetAngle = Math.atan2(direction.x, direction.z);
      const currentAngle = THREE.MathUtils.euclideanModulo(this.model.rotation.y + Math.PI, 2 * Math.PI) - Math.PI;

      let angleDifference = targetAngle - currentAngle;
      if (angleDifference > Math.PI) angleDifference -= 2 * Math.PI;
      if (angleDifference < -Math.PI) angleDifference += 2 * Math.PI;

      const lerpedAngle = currentAngle + angleDifference * 0.1;
      this.model.rotation.y = lerpedAngle;

      const distance = this.position.distanceTo(this.targetPosition);

      if (distance > 0.63) {
        const force = new Vec3(
          direction.x * this.speed,
          0,
          direction.z * this.speed
        );
        this.body.velocity.set(force.x, force.y, force.z);
        this.playAnimation('run'); // Toca a animação de correr
      } else {
        this.body.velocity.set(0, 0, 0);
        this.moving = false;
        this.playAnimation('idle'); // Retorna para a animação idle
      }
    } else {
      this.body.velocity.set(0, 0, 0);
      this.playAnimation('idle'); // Garante que a animação idle esteja tocando
    }

    this.position.set(this.body.position.x, this.body.position.y, this.body.position.z);
    this.model.position.copy(this.position);
    this.mixer.update(deltaTime); // Atualiza o mixer de animação
  }
}

export default Player;

-- FILE: ./src/network/SocketManager.js --
import { io } from 'socket.io-client';

class SocketManager {
    constructor() {
        this.socket = io('http://localhost:3000');
        this.players = {};
        this.setupListeners();
    }

    setupListeners() {

        this.socket.on('connect', () => {
            console.log('Connected to server');
        });

        this.socket.on('playerUpdate', (data) => {
            console.log('Player data:', data);
        });

        this.socket.on('disconnect', () => {
            console.log('Disconnected from server');
        });

        this.socket.on("playerMoved", (data) => {
            if (!this.players[data.id]) {
                this.players[data.id] = new THREE.Mesh(
                    new THREE.BoxGeometry(1, 1, 1),
                    new THREE.MeshStandardMaterial({ color: 0xff0000 })
                );
                scene.add(this.players[data.id]);
            }
            this.players[data.id].position.set(data.position.x, data.position.y, data.position.z);
        });

        this.socket.on("playerDisconnected", (id) => {
            if (this.players[id]) {
                scene.remove(this.players[id]);
                delete this.players[id];
            }
        });
    }

    send(event, data) {
        this.socket.emit(event, data);
    }

    sendMove(position) {
        this.socket.emit("move", position);
    }
}

export default new SocketManager();


-- FILE: ./src/ui/AdvancedDebug.js --
class AdvancedDebug {
    constructor(renderer, scene) {
        this.renderer = renderer;
        this.scene = scene;

        this.container = document.createElement('div');
        this.container.style.position = 'absolute';
        this.container.style.top = '170px';
        this.container.style.right = '10px';
        this.container.style.color = 'white';
        this.container.style.fontFamily = 'Arial, sans-serif';
        this.container.style.fontSize = '12px';
        this.container.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';
        this.container.style.padding = '10px';
        this.container.style.borderRadius = '5px';
        this.container.style.display = 'none'; // Esconde inicialmente
        document.body.appendChild(this.container);

        this.statsVisible = false;

        // Inicializa variáveis para o cálculo do FPS
        this.lastFrameTime = performance.now();
        this.frameCount = 0;
        this.fps = 0;
        this.fpsHistory = []; // Para armazenar os FPS
        this.fpsHistoryLength = 60; // Número de frames para calcular a média

        // Ativa/desativa o depurador com F8
        window.addEventListener('keydown', (event) => {
            if (event.key === 'F8') {
                this.toggle();
            }
        });

        this.toggle();
    }

    toggle() {
        this.statsVisible = !this.statsVisible;
        this.container.style.display = this.statsVisible ? 'block' : 'none';
    }

    update() {
        if (!this.statsVisible) return;

        const now = performance.now();
        this.frameCount++;

        // Calcule o FPS com base no tempo decorrido
        const deltaTime = now - this.lastFrameTime;
        this.lastFrameTime = now;

        // Calcule o FPS atual
        const currentFPS = 1000 / deltaTime;

        // Armazene o FPS atual na história
        this.fpsHistory.push(currentFPS);
        if (this.fpsHistory.length > this.fpsHistoryLength) {
            this.fpsHistory.shift(); // Remove o FPS mais antigo
        }

        // Calcule a média do FPS
        this.fps = this.fpsHistory.reduce((a, b) => a + b, 0) / this.fpsHistory.length;

        const info = this.renderer.info;

        const memory = performance.memory || {};
        const usedMemory = memory.usedJSHeapSize / 1024 / 1024 || 0;
        const totalMemory = memory.totalJSHeapSize / 1024 / 1024 || 0;

        const sceneStats = this.getSceneStats(this.scene);

        this.container.innerHTML = `
            <b>Renderer Info:</b><br>
            - FPS: ${Math.round(this.fps)}<br>
            - Draw Calls: ${info.render.calls}<br>
            - Triangles: ${info.render.triangles}<br>
            - Vertices: ${info.render.vertices}<br>
            - Textures: ${info.memory.textures}<br>
            - Geometries: ${info.memory.geometries}<br>
            <br>
            <b>Memory Usage:</b><br>
            - Used: ${usedMemory.toFixed(2)} MB<br>
            - Total: ${totalMemory.toFixed(2)} MB<br>
            <br>
            <b>Scene Stats:</b><br>
            - Objects: ${sceneStats.objects}<br>
            - Lights: ${sceneStats.lights}<br>
        `;
    }

    getSceneStats(scene) {
        let objects = 0;
        let lights = 0;

        scene.traverse((object) => {
            if (object.isLight) lights++;
            objects++;
        });

        return { objects, lights };
    }
}

export default AdvancedDebug;

-- FILE: ./src/ui/DebugInfo.js --
import Stats from 'stats.js';

class DebugInfo {
    constructor() {
        this.stats = new Stats();
        this.stats.showPanel(0); // Painel 0: FPS
        this.enabled = false;

        // Adiciona o stats ao DOM, mas começa oculto
        this.stats.dom.style.position = 'absolute';
        this.stats.dom.style.top = '0px';
        this.stats.dom.style.left = '0px';
        this.stats.dom.style.display = 'none'; // Esconde inicialmente
        document.body.appendChild(this.stats.dom);

        // Configurar o evento para ativar/desativar com F8
        window.addEventListener('keydown', (event) => {
            if (event.key === 'F8') {
                this.toggle();
            }
        });
    }

    toggle() {
        this.enabled = !this.enabled;
        this.stats.dom.style.display = this.enabled ? 'block' : 'none';
    }

    begin() {
        if (this.enabled) this.stats.begin();
    }

    end() {
        if (this.enabled) this.stats.end();
    }

    showMemoryUsage() {
        if (!this.enabled) return;

        // Obtém informações de memória (apenas Chrome)
        if (performance && performance.memory) {
            const memoryInfo = performance.memory;
            const usedMB = (memoryInfo.usedJSHeapSize / 1024 / 1024).toFixed(2);
            const totalMB = (memoryInfo.totalJSHeapSize / 1024 / 1024).toFixed(2);
            console.log(`Memory Usage: ${usedMB} MB / ${totalMB} MB`);
        } else {
            console.warn('Memory API not supported in this browser.');
        }
    }
}

export default DebugInfo;


-- FILE: ./src/ui/Hud.js --
class Hud {
    constructor() {
        this.container = document.createElement('div');
        this.container.style.position = 'absolute';
        this.container.style.top = '10px';
        this.container.style.left = '10px';
        this.container.style.color = 'white';
        this.container.style.fontFamily = 'Arial, sans-serif';
        this.container.style.fontSize = '16px';
        this.container.innerHTML = 'Vida: 200 | Pontuação: 0';
        document.body.appendChild(this.container);
    }

    update(life, score) {
        this.container.innerHTML = `Vida: ${life} | Pontuação: ${score}`;
    }
}

export default Hud;


-- FILE: ./src/ui/Minimap.js --
import * as THREE from 'three';

class Minimap {
    constructor(scene, player, renderer) {
        this.scene = scene;
        this.player = player;
        this.renderer = renderer;

        // Cria a câmera do minimapa
        const aspect = 1; // Mantém uma proporção quadrada
        this.camera = new THREE.OrthographicCamera(
            -10, 10, 10, -10, 0.1, 100 // Limites do frustum
        );

        // Posiciona a câmera acima da cena
        this.camera.position.set(0, 20, 0); // Vista de cima
        this.camera.lookAt(0, 0, 0); // Aponta para o centro da cena

        // Configura o render target
        this.minimapRenderTarget = new THREE.WebGLRenderTarget(200, 200);

        // Adiciona um canvas para o minimapa
        const minimapCanvas = this.renderer.domElement.cloneNode();
        minimapCanvas.style.position = 'absolute';
        minimapCanvas.style.top = '10px';
        minimapCanvas.style.right = '10px';
        minimapCanvas.style.width = '150px';
        minimapCanvas.style.height = '150px';
        minimapCanvas.style.border = '2px solid white';
        document.body.appendChild(minimapCanvas);

        this.minimapRenderer = new THREE.WebGLRenderer({
            canvas: minimapCanvas,
            antialias: true,
        });
        this.minimapRenderer.setSize(150, 150);
    }

    update() {
        // Centraliza a câmera do minimapa no jogador
        this.camera.position.x = this.player.position.x;
        this.camera.position.z = this.player.position.z;
        this.camera.updateProjectionMatrix();

        // Renderiza a cena no canvas do minimapa
        this.minimapRenderer.render(this.scene, this.camera);
    }
}

export default Minimap;


-- FILE: ./vite.config.js --
import { defineConfig } from 'vite';
import path from 'path';

export default defineConfig({
    root: './public', // Define a raiz como o diretório do projeto
    build: {
        outDir: path.resolve(__dirname, './dist'), // Saída dos arquivos
        emptyOutDir: true, // Limpa a pasta de saída antes do build
    },
    resolve: {
        alias: {
            '@': path.resolve(__dirname, './src'), // Alias para a pasta "src"
            three: path.resolve(__dirname, './node_modules/three'),
        },
    },
    server: {
        open: false, // Abre automaticamente o navegador
    },
});
